<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Core Clinical Sciences">

<title>TransportMAIC</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="TransportMAIC-v0.1RY_files/libs/clipboard/clipboard.min.js"></script>
<script src="TransportMAIC-v0.1RY_files/libs/quarto-html/quarto.js"></script>
<script src="TransportMAIC-v0.1RY_files/libs/quarto-html/popper.min.js"></script>
<script src="TransportMAIC-v0.1RY_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="TransportMAIC-v0.1RY_files/libs/quarto-html/anchor.min.js"></script>
<link href="TransportMAIC-v0.1RY_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="TransportMAIC-v0.1RY_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="TransportMAIC-v0.1RY_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="TransportMAIC-v0.1RY_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="TransportMAIC-v0.1RY_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">TransportMAIC</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Core Clinical Sciences </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="mathematical-proof-of-maic-in-transport-health" class="level1">
<h1>Mathematical proof of MAIC in transport health</h1>
<section id="aim" class="level2">
<h2 class="anchored" data-anchor-id="aim">Aim</h2>
<p>The reason why we need to do the transportability analysis is to tackle with the problem that there are potential differences between study population and target population. We consider two aspects: confounding in study population and distributions of effect modifiers (EM) in both population.</p>
</section>
<section id="weights" class="level2">
<h2 class="anchored" data-anchor-id="weights">Weights</h2>
<p>We apply propensity weight, <span class="math inline">\(w_1\)</span>, and participation weight, <span class="math inline">\(w_2\)</span>, to account for aforementioned aspects respectively. The actual weight of matching, <span class="math inline">\(w_{\text{actual}}\)</span>, is thus defined as the product of these two weights as</p>
<p><span class="math display">\[
w_{\text{actual}} = w_1 \times w_2
\]</span></p>
<p>Let <span class="math inline">\(A\)</span> be the treatment and <span class="math inline">\(L\)</span> be the covariates, where <span class="math inline">\(A=1\)</span> represents getting the treatment and <span class="math inline">\(A=0\)</span> represents not getting the treatment. Then</p>
<p><span class="math display">\[
w_1 = \frac{1}{Pr(A=a\mid L=l)}
\]</span></p>
<p>Let <span class="math inline">\(S\)</span> be the study participation indicator and <span class="math inline">\(E\)</span> be the effect modifiers, where <span class="math inline">\(S=1\)</span> represents participating the study and <span class="math inline">\(S=0\)</span> represents not participating the study. Then</p>
<p><span class="math display">\[
w_2 = \frac{Pr(S=0\mid E=e)}{Pr(S=1\mid E=e)}
\]</span></p>
<p>For <span class="math inline">\(w_1\)</span>, since we have the IPD availability, we do logistic regression to get the MLE estimates. For <span class="math inline">\(w_2\)</span>, since we just have AgD of EM’s, we do Method of Moments to get the MoM estimates.</p>
<p>For tansportability analysis, the ultimate goal is to prove that</p>
<p><span class="math display">\[
E\left[w_{\text{actual}}\cdot Y\mid A=a, S=1 \right] = E\left[Y^a\mid S=0 \right]
\]</span></p>
<p>Specifically, our missions are</p>
<p><span class="math display">\[
\text{When } A = a:Y\text{ to } Y^a
\]</span></p>
<p><span class="math display">\[
S=1\text{ to } S=0
\]</span></p>
<p>which will be accomplished by <span class="math inline">\(w_1\)</span> and <span class="math inline">\(w_2\)</span> respectively.</p>
</section>
<section id="matching-adjustment" class="level2">
<h2 class="anchored" data-anchor-id="matching-adjustment">Matching Adjustment</h2>
<p>Consider one intervention of interest as <span class="math inline">\(A\)</span> and the comparator intervention as <span class="math inline">\(B\)</span>. Assume that we have the availability of IPD for <span class="math inline">\(A\)</span> but just AgD for <span class="math inline">\(B\)</span>. For each individual patient <span class="math inline">\(i\)</span>, let <span class="math inline">\(X_{Ai}\)</span> be the available IPD of covariates for intervention <span class="math inline">\(A\)</span>. Let <span class="math inline">\(\bar{X}_B\)</span> be the available AgD of covariates for comparator <span class="math inline">\(B\)</span>.</p>
<section id="method-of-moments" class="level3">
<h3 class="anchored" data-anchor-id="method-of-moments">Method of Moments</h3>
<p>With the limited IPD availability, we match the study population to the target population via Method of Moments. Assume that the weight for individual patient <span class="math inline">\(i\)</span> follows the logistic regression:</p>
<p><span class="math display">\[
w_i = \exp(\alpha + X_{Ai}\cdot k)
\]</span></p>
<p>The Method of Moments goes as</p>
<p><span class="math display">\[
\frac{\sum_{i=1}^{N}X_{Ai}\cdot w_i}{\sum_{i=1}^{N}w_i} = \bar{X_{B}}
\]</span></p>
<p>Without loss of generality, it can be assumed that <span class="math inline">\(\bar{X}_B=0\)</span> in theoretical formula (e.g., we could transform/center baseline characteristics in both trials by subtracting <span class="math inline">\(\bar{X}_B\)</span> in format and derive the procedure as following</p>
<p><span class="math display">\[
    \begin{align}
        \frac{\sum_{i=1}^{N}X_{Ai}\cdot w_i}{\sum_{i=1}^{N}w_i} &amp;= \bar{X}_B \\
        \sum_{i=1}^{N}X_{Ai}\cdot w_i &amp;= \bar{X}_B\cdot \sum_{i=1}^{N}w_i\\
        \sum_{i=1}^{N}X_{Ai}\cdot w_i &amp;= 0 = Q'(k)
        \nonumber
    \end{align}
\]</span></p>
<p>where <span class="math inline">\(Q(k) = \sum_{i=1}^{N}w_i = \sum_{i=1}^{N}\exp(X_{Ai}\cdot k)\)</span> (<span class="math inline">\(\alpha\)</span> gets cancelled during the procedure).</p>
<p>Since <span class="math inline">\(Q(k)\)</span> can be proved as convex, any infinite solution of (*) is unique and corresponds to the global minimum of <span class="math inline">\(Q(k)\)</span>. We can follow the process to eventually get the estimates of <span class="math inline">\(w_i\)</span>.</p>
</section>
</section>
<section id="maic" class="level2">
<h2 class="anchored" data-anchor-id="maic">MAIC</h2>
<p>Let <span class="math inline">\(A\)</span> be the treatment and <span class="math inline">\(L\)</span> be the covariates, where <span class="math inline">\(A=1\)</span> represents getting the treatment and <span class="math inline">\(A=0\)</span> represents not getting the treatment. Odds of being treated is as <span class="math display">\[
    \text{OR} = \frac{Pr(A = 1|L)}{Pr(A = 0|L)}
\]</span></p>
<p>The inverse-odds weight used in MAIC is defined as <span class="math display">\[
    w_i = \frac{Pr(A = 0|L)}{Pr(A = 1|L)}
\]</span></p>
<p>For the study population and target population, following the MAIC approach:</p>
<ul>
<li>Applying Methods of Moments to match these two population and calculating the weights <span class="math inline">\(w_i\)</span> for each individual</li>
<li>The weights refers to a pseudo population (indicated as ““PS(MAIC)”“)</li>
<li>Let <span class="math inline">\(Y\)</span> be the outcome of interest, <span class="math inline">\(A\)</span> be the treatment indicator with specific type of treatment labelled by <span class="math inline">\(a\)</span>, and <span class="math inline">\(S\)</span> be the study participation indicator where <span class="math inline">\(S=1\)</span> represents the participation of study and <span class="math inline">\(S=0\)</span> represents the non-participation of study. We can calculate the following expectation among the weighted MAIC pseudo population</li>
</ul>
<p><span class="math display">\[
   E_{\text{PS(MAIC)}}[Y|A = a,S = 1]
\]</span></p>
<ul>
<li>The ultimate goal is to estimate</li>
</ul>
<p><span class="math display">\[
  E[Y^a|S=0]
\]</span></p>
<p>To obtain the average treatment effect in target population (PATE), we have the following two potential outcomes, <span class="math inline">\(Y^1\)</span> under intervention of interest, and <span class="math inline">\(Y^0\)</span> under comparator. In the study population, where <span class="math inline">\(S=1\)</span>, the trial average treatment effect (TATE) is</p>
<p><span class="math display">\[
    E[Y^1-Y^0|S=1]
\]</span></p>
<p>and the PATE is</p>
<p><span class="math display">\[
    E[Y^1-Y^0]
\]</span></p>
</section>
</section>
<section id="summary-of-maic-in-transportability" class="level1">
<h1>Summary of MAIC in Transportability</h1>
<p>The MAIC transportability method provides the unbiased estimator of <span class="math inline">\(E(Y^a)\)</span> by weighing the observations under <span class="math inline">\((A,L)=(a,l)\)</span> via inverse-odds</p>
<p><span class="math display">\[
    w_i = \frac{1}{\text{OR}_{i}} = \frac{Pr(A = 0|L)}{Pr(A = 1|L)}
\]</span></p>
<p>Among the pseudo population after the weighting process (note: since <span class="math inline">\(w_i&gt;1\)</span> we treat the pseudo population with duplicates of original population), the weighted mean of observations in <span class="math inline">\(A=a\)</span> group is</p>
<p><span class="math display">\[
    \begin{align}
    E_{\text{PS(MAIC)}}[Y|A=a] &amp;= \frac{E_{\text{PS(MAIC)}}[Y\cdot I(A=a)]}{E_{\text{PS(MAIC)}}[I(A=a)]} &amp;&amp; \text{(by law of probability)}
    \end{align}
\]</span></p>
<p>By definition of the expectation in pseudo population, we have the relationship between <span class="math inline">\(E_{\text{PS}}\)</span> and <span class="math inline">\(E\)</span></p>
<p><span class="math display">\[
    E_{\text{PS}}[Y\cdot I(A=a)] = E[w^A\cdot YI(A=a)]
\]</span></p>
<p>Thus, when <span class="math inline">\(w^A = w_i\)</span> as the inverse-odds</p>
<p><span class="math display">\[
    E_{\text{PS(MAIC)}}[Y|A=a] = \frac{E\left[\frac{Pr(A=0|L)}{Pr(A=1|L)}\cdot YI(A=a)\right]}{E\left[\frac{Pr(A=0|L)}{Pr(A=1|L)}\right]}
\]</span></p>
<p>When <span class="math inline">\(a = 1\)</span>:</p>
<p><span class="math display">\[
    E_{\text{PS(MAIC)}}[Y \mid A=1] = \frac{E\left[\frac{\Pr(A=0 \mid L)}{\Pr(A=1 \mid L)} \cdot Y I(A=1)\right]}{E\left[\frac{\Pr(A=0 \mid L)}{\Pr(A=1 \mid L)} \cdot I(A=1)\right]}
\]</span></p>
<p>In the denominator above, since</p>
<p><span class="math display">\[
\begin{align}
      E\left[\frac{I(A=1)}{\Pr(A=1 \mid L)}\right] &amp;= E\left[E\left[\frac{I(A=1)}{\Pr(A=1 \mid L)} \mid L\right]\right] \quad \text{(since $EX = E[E(X\mid A)]$)}\\
    &amp;= E\left[\frac{1}{\Pr(A=1 \mid L)} \times \Pr(A=1 \mid L)\right] \\
    &amp;= 1  
    \nonumber
\end{align}
\]</span></p>
<p>Thus</p>
<p><span class="math display">\[
    E_{\text{PS(MAIC)}}\left[Y|A=1\right] = \frac{1}{Pr(A=0)}\cdot E\left[\frac{Pr(A=0|L)}{Pr(A=1|L)}\cdot YI(A=1)\right]
\]</span></p>
<p>We want to estimate <span class="math inline">\(E[Y^1|S=0]\)</span>. According to consistency: <span class="math inline">\(Y=Y^a\)</span> under <span class="math inline">\(A=a\)</span>. The counterfactual mean of interests <span class="math inline">\(E(Y^1)\)</span> can be unbiased estimated by the weight mean <span class="math inline">\(E[w^A\cdot Y|A=1]\)</span>.</p>
<p><span class="math display">\[
    \begin{align}
    E[w^A\cdot Y|A=1] &amp;= E_{\text{PS(MAIC)}}[Y|A=1] \\
    &amp;= \frac{1}{\Pr(A=0)}\cdot E\left[\frac{\Pr(A=0|L)}{\Pr(A=1|L)}\cdot YI(A=1)\right] \\
    &amp;= \frac{1}{\Pr(A=0)}\cdot E\left[E\left[\frac{\Pr(A=0|L)}{\Pr(A=1|L)}\cdot YI(A=1)\right]|L\right] \\
    &amp;= \frac{1}{\Pr(A=0)}\cdot E\left[E\left[\frac{\Pr(A=0|L)}{\Pr(A=1|L)}\cdot Y^{1}I(A=1)\right]|L\right] &amp;&amp; \text{(by consistency)}\\
    &amp;= \frac{1}{\Pr(A=0)}\cdot E\left[E\left[ \frac{\Pr(A=0|L)\cdot Y^1}{\Pr(A=1|L)} |L\right] \times E[I(A=1)|L]\right] &amp;&amp; \text{(by $(Y^0, Y^1\perp A)\mid L$)} \\
    &amp;= \frac{1}{\Pr(A=0)}\cdot E\left[\frac{\Pr(A=0|L)}{\Pr(A=1|L)}\cdot E[Y^1|L] \times \Pr(A=1|L)\right] &amp;&amp; \text{(pending to modify here)}\\
    &amp;=  E\left[E\left[Y^1|L\right]\right] \\
    &amp;= E[Y^1]
    \end{align}
\]</span></p>
<p>Similar idea straightforwardly works for the condition when <span class="math inline">\(A=0\)</span>.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>